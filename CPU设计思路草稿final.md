# 零 更新情况

###### 	一更

- 新增了jal与jr指令

- 调整了NPC中混乱的内部结构

  +++

  ###### 二更

- 新增了lb与sb指令

- 新添选择器DMSel
- 全面更新了数据通路表和控制信号取值表

# 一 主体部件内部构建思路

## 1 NPC（次地址计算单元）

​	NPC是用于计算PC值的模块，对于P3课下要求而言，只需实现PC+4与在BEQ指令下的立即数跳转，因此整体结构就是两种计算方式用一个MUX来控制输出，此外需要注意BEQ的跳转条件，即 ***($i == $j)***， 因此传入了一个输入isZero来判断是否符合跳转条件。

## 2 IM （指令储存器）

​	IM通过获取PC的输出，在ROM中取出对应的指令，注意到PC是+4的，因此我们需要对PC做逻辑右移2位的操作，此外题面提醒只需要12位的地址宽度，遂用extender将32位的右移后的结果转化为12位。

## 3 GRF （寄存器堆）

​	GRF接收IM指令的各个部分，并作用于各个寄存器上，可分为读和写两个操作。这里直接复用P0课下即可，但是猪脚给的工具中自带寄存器堆，所以调试完后记得关注一下接线问题。

​	*~~p.s. 前几次提交确实没注意这个问题，喜提一串WA，后来发现是接线没对准（~~*

## 4 ALU （算术逻辑单元）

​	ALU是CPU主管计算的模块，涉及到数字的计算，地址的计算等等，对于不同的需求我们分别计算，最后用一个~~巨大的~~MUX选择输出结果即可，控制信号设为ALUOp，由CTRL统一管理。

## 5 DM （数据储存器）

​	DM是管理内存的模块，目前涉及到DM的指令只有lw，一个简单RAM即可实现需求，和IM同理，需要通过逻辑右移2位来找到RAM中对应的内存位置。

## 6 EXT （位扩展器）

​	EXT是用来处理立即数的模块，目前只涉及到16位立即数扩展至32位，通过查看手册我们注意到，ORI指令的实现涉及到唯一与众不同的无符号扩展，因此需要一个EXTOp做控制信号，根据不同指令判断扩展类型。

## 7 CTRL （控制器）

​	CTRL是根据指令统一获取数据通路中所有控制信号的模块，根据教程，我们先通过“与逻辑”模块来判断指令类型，用tunnel存储，再在“或逻辑”模块中利用不同指令对应的tunnel，来为各控制信号赋值，值得一提的是，部分控制信号可扩展度较高，可以预先先开好更多位，方便以后添加指令，目前先将未涉及的高位赋0即可。

# 二 数据通路分析

+++

**操作与相应的数据通路**

我们以一个指令为单位，将其在单周期CPU中的操作思考一遍，即可得到对应的各模块输入，汇总如下表*（无关紧要的输入用///代替）*

p.s.jal和jr的相关部件输入后续补充

| components | NPC   | NPC        | NPC    | PC      | IM    | RF          | RF          | RF          | RF    | EXT        | ALU    | ALU     | DM    | DM     |
| ---------- | ----- | ---------- | ------ | ------- | ----- | ----------- | ----------- | ----------- | ----- | ---------- | ------ | ------- | ----- | ------ |
| *INPUT*    | *PC*  | *Imm*      | *RA*   | *DI*    | *A*   | *A1*        | *A2*        | *A3*        | *WD*  | *Imm16*    | *A*    | *B*     | *A*   | *WD*   |
| addu       | PC.DO | ///        | ///    | NPC.npc | PC.DO | IM.D[25:21] | IM.D[20:16] | IM.D[15:11] | ALU.C | ///        | RF.RD1 | RF.RD2  | ///   | ///    |
| subu       | PC.DO | ///        | ///    | NPC.npc | PC.DO | IM.D[25:21] | IM.D[20:16] | IM.D[15:11] | ALU.C | ///        | RF.RD1 | RF.RD2  | ///   | ///    |
| ori        | PC.DO | ///        | ///    | NPC.npc | PC.DO | IM.D[25:21] | ///         | IM.D[20:16] | ALU.C | IM.D[15:0] | RF.RD1 | EXT.ext | ///   | ///    |
| lw         | PC.DO | ///        | ///    | NPC.npc | PC.DO | IM.D[25:21] | ///         | IM.D[20:16] | DM.RD | IM.D[15:0] | RF.RD1 | EXT.ext | ALU.C | ///    |
| sw         | PC.DO | ///        | ///    | NPC.npc | PC.DO | IM.D[25:21] | IM.D[20:16] | ///         | ///   | IM.D[15:0] | RF.RD1 | EXT.ext | ALU.C | RF.RD2 |
| beq        | PC.DO | IM.D[15:0] | ///    | NPC.npc | PC.DO | IM.D[25:21] | IM.D[20:16] | ///         | ///   | ///        | RF.RD1 | RF.RD2  | ///   | ///    |
| lui        | PC.DO | ///        | ///    | NPC.npc | PC.DO | IM.D[25:21] | ///         | IM.D[20:16] | ALU.C | IM.D[15:0] | RF.RD1 | EXT.ext | ///   | ///    |
| jal        | PC.DO | IM.D[25:0] | ///    | NPC.npc | PC.DO | ///         | ///         | 0x1f        | PC4   | ///        | ///    | ///     | ///   | ///    |
| jr         | PC.DO | ///        | RF.RD1 | NPC.npc | PC.DO | IM.D[25:21] | ///         | ///         | ///   | ///        | ///    | ///     | ///   | ///    |
| lb         | PC.DO | ///        | ///    | NPC.npc | PC.DO | IM.D[25:21] | ///         | IM.D[20:16] | DM.RD | IM.D[15:0] | RF.RD1 | EXT.ext | ALU.C | ///    |
| sb         | PC.DO | ///        | ///    | NPC.npc | PC.DO | IM.D[25:21] | IM.D[20:16] | ///         | ///   | IM.D[15:0] | RF.RD1 | EXT.ext | ALU.C | RF.RD2 |

+++

# 三 基于上表分析数据通路中的三个MUX

+++

## 1 由GRFA3Sel控制的RF.A3选择器

​	未加入jal指令前，RFA3共有2个取值，分别是IM.D[20:16] (ori/lw/lui)，IM.D[15:11] (addu,subu)， 其余指令取xx即可。

## 2 由GRFWDSel控制的RF.WD选择器

​	未加入jal指令前，RFWD共有2个取值，分别是ALU.C (addu, subu, ori, lui)，DM.RD(lw)， 其余指令取xx即可。

## 3 由ALUBSel控制的ALU.B选择器

​	截至目前，ALU.B共有2个取值，分别是RF.RD2(addu, subu, beq) , EXT.ext(ori, lw, sw,lui), 其余指令取xx即可。

***综合所有选择器与控制信号，更新表格如下！***

+++

**操作与对应控制信号取值表**

|      | NPCOp       | GRFWr | EXTOp | ALUOp | DMWr | GRFA3Sel | GRFWDSel | ALUBSel | DMSel |
| ---- | ----------- | ----- | ----- | ----- | ---- | -------- | -------- | ------- | ----- |
| addu | 00（PC4）   | 1     | x     | 000   | 0    | 01       | 00       | 00      | xx    |
| subu | 00          | 1     | x     | 010   | 0    | 01       | 00       | 00      | xx    |
| beq  | 01(PC4+IMM) | 0     | x     | xxx   | 0    | 00       | xx       | 00      | xx    |
| sw   | 00          | 0     | 1     | 000   | 1    | xx       | xx       | 01      | 00    |
| lw   | 00          | 1     | 1     | 000   | 0    | 00       | 01       | 01      | 00    |
| lui  | 00          | 1     | 1     | 011   | 0    | 00       | 00       | 01      | xx    |
| ori  | 00          | 1     | 0     | 001   | 0    | 00       | 00       | 01      | xx    |
| jal  | 10          | 1     | x     | xxx   | 0    | 10       | 10       | xx      | xx    |
| jr   | 11          | 0     | x     | xxx   | 0    | xx       | xx       | xx      | xx    |
| lb   | 00          | 1     | 1     | 000   | 0    | 00       | 01       | 01      | 01    |
| sb   | 00          | 0     | 1     | 000   | 1    | xx       | xx       | 01      | 01    |

# 四 思考题汇总

## 1.请指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。

- ###### 状态存储器：PC，GRF，DM

- ###### 状态转移器：IM，NPC，CTRL，EXT

## 2.现在模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？

合理；

- ROM作为指令存储器：指令在CPU执行程序期间，是不会更改的，这一点与ROM只读不存的特点相契合。
- Register作为寄存器堆：Register适用于快速读取临时数据，非常适合于搭建寄存器堆
- RAM作为数据储存器：首先RAM支持读写，其次它可以连续存储数据，适合做内存存储。

## 3.在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。

NPC；设计思路请转至[[一 1 NPC](#1-NPC（次地址计算单元）)],目的便是让PC只负责计数，而计算下一时刻的PC值在NPC中完成。

## 4.事实上，实现 `nop` 空指令，我们并不需要将它加入控制信号真值表，为什么？

结果上来说，nop并没有影响到状态转移和状态存储，所以指令本身对CPU没有任何影响，自然不会生成控制信号。

目的上来说，nop的作用就是让CPU执行一个周期而不做任何操作，也就不会有控制信号一说了。

## 5.阅读 Pre 的 [“MIPS 指令集及汇编语言”](http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/) 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。

个人认为覆盖度已经相当之高，唯一一点小问题就是没有检测一些特殊的寄存器，如&zero，检测结果是在读取的时候，&zero的值都保持为0，避免了特殊寄存器出现的特殊错误。